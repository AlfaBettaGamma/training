def ArrayChunk(M: list) -> int:    N = M[len(M) // 2]    N_index = len(M) // 2    i1 = 0    i2 = len(M) - 1    while True:        if M[i1] < N:            i1 += 1        if M[i2] > N:            i2 -= 1        if i1 == i2 - 1 and M[i1] > M[i2]:            inter_el = M[i1]            M[i1] = M[i2]            M[i2] = inter_el            N = M[len(M) // 2]            N_index = len(M) // 2            i1 = 0            i2 = len(M) - 1            continue        if i1 == i2 or i1 == i2 - 1 and M[i1] < M[i2]:            return N_index        if M[i1] >= N and M[i2] <= N:            if M[i1] == N:                N_index = i2            if M[i2] == N:                N_index = i1            inter_el = M[i1]            M[i1] = M[i2]            M[i2] = inter_eldef QuickSort(array: list, left: int, right: int):    if len(array[left:right]) < 2:        return None    arr = array[left:right + 1]    index = ArrayChunk(arr)    array[left:right + 1] = arr    QuickSort(array, left, left + index)    QuickSort(array, left + index, right)def QuickSortTailOptimization(array: list, left: int, right: int):    if len(array[left:right]) < 2:        return None    arr = array[left:right + 1]    index = ArrayChunk(arr)    array[left:right + 1] = arr    QuickSort(array, left, left + index)    QuickSort(array, left + index, right)def KthOrderStatisticsStep(Array: list, L: int, R: int, k: int) -> list:    arr = Array[L:R + 1]    i = ArrayChunk(arr) + L    Array[L:R + 1] = arr    if i == k:        return [i, i]    if i > k:        return [L, i - 1]    if i < k:        return [i + 1, R]